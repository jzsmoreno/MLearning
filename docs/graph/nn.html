<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>likelihood.graph.nn API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>likelihood.graph.nn</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import warnings
from typing import List, Tuple

import numpy as np
import pandas as pd
import tensorflow as tf
from numpy import ndarray
from pandas.core.frame import DataFrame
from sklearn.metrics import f1_score
from sklearn.model_selection import train_test_split

from likelihood.tools import generate_feature_yaml


def compare_similarity(arr1: ndarray, arr2: ndarray) -&gt; int:
    &#34;&#34;&#34;Compares the similarity between two arrays of categories.

    Parameters
    ----------
    arr1 : `ndarray`
        The first array of categories.
    arr2 : `ndarray`
        The second array of categories.

    Returns
    -------
    count: `int`
        The number of categories that are the same in both arrays.
    &#34;&#34;&#34;

    count = 0
    for i in range(len(arr1)):
        if arr1[i] == arr2[i]:
            count += 1
    return count


def cal_adjency_matrix(
    df: DataFrame, exclude_subset: List[str] = [], sparse: bool = True, **kwargs
) -&gt; Tuple[dict, ndarray]:
    &#34;&#34;&#34;Calculates the adjacency matrix for a given DataFrame.
    The adjacency matrix is a matrix that represents the similarity between each pair of categories.
    The similarity is calculated using the `compare_similarity` function.
    The resulting matrix is a square matrix with the same number of rows and columns as the input DataFrame.

    Parameters
    ----------
    df : `DataFrame`
        The input DataFrame containing the categories.
    exclude_subset : `List[str]`, optional
        A list of categories to exclude from the calculation of the adjacency matrix.
    sparse : `bool`, optional
        Whether to return a sparse matrix or a dense matrix.
    **kwargs : `dict`
        Additional keyword arguments to pass to the `compare_similarity` function.

    Keyword Arguments:
    ----------
    similarity: `int`
        The minimum number of categories that must be the same in both arrays to be considered similar.

    Returns
    -------
    adj_dict : `dict`
        A dictionary containing the categories.
    adjacency_matrix : `ndarray`
        The adjacency matrix.
    &#34;&#34;&#34;

    yaml_ = generate_feature_yaml(df)
    categorical_columns = yaml_[&#34;categorical_features&#34;]
    if len(exclude_subset) &gt; 0:
        categorical_columns = [col for col in categorical_columns if col not in exclude_subset]

    if len(categorical_columns) &gt; 1:
        df_categorical = df[categorical_columns].copy()
    else:
        categorical_columns = [
            col
            for col in df.columns
            if (
                col not in exclude_subset
                and pd.api.types.is_integer_dtype(df[col])
                and len(df[col].unique()) &gt; 2
            )
        ]
        df_categorical = df[categorical_columns].copy()

    assert len(df_categorical) &gt; 0

    similarity = kwargs[&#34;similarity&#34;] if &#34;similarity&#34; in kwargs else len(df_categorical.columns) - 1
    assert similarity &lt;= df_categorical.shape[1]

    adj_dict = {}
    for index, row in df_categorical.iterrows():
        adj_dict[index] = row.to_list()

    adjacency_matrix = np.zeros((len(df_categorical), len(df_categorical)))

    for i in range(len(df_categorical)):
        for j in range(len(df_categorical)):
            if compare_similarity(adj_dict[i], adj_dict[j]) &gt;= similarity:
                adjacency_matrix[i][j] = 1

    if sparse:
        num_nodes = adjacency_matrix.shape[0]

        indices = np.argwhere(adjacency_matrix != 0.0)
        indices = tf.constant(indices, dtype=tf.int64)
        values = tf.constant(adjacency_matrix[indices[:, 0], indices[:, 1]], dtype=tf.float32)
        adjacency_matrix = tf.sparse.SparseTensor(
            indices=indices, values=values, dense_shape=(num_nodes, num_nodes)
        )

        return adj_dict, adjacency_matrix
    else:
        return adj_dict, adjacency_matrix


class Data:
    def __init__(
        self,
        df: DataFrame,
        target: str | None = None,
        exclude_subset: List[str] = [],
    ):
        _, adjacency = cal_adjency_matrix(df, exclude_subset=exclude_subset, sparse=True)
        if target is not None:
            X = df.drop(columns=[target] + exclude_subset)
        else:
            X = df.drop(columns=exclude_subset)
        self.columns = X.columns
        X = X.to_numpy()
        self.x = np.asarray(X).astype(np.float32)
        self.adjacency = adjacency
        if target is not None:
            self.y = np.asarray(df[target].values).astype(np.int32)


@tf.keras.utils.register_keras_serializable(package=&#34;Custom&#34;, name=&#34;VanillaGNNLayer&#34;)
class VanillaGNNLayer(tf.keras.layers.Layer):
    def __init__(self, dim_in, dim_out, kernel_initializer=&#34;glorot_uniform&#34;, **kwargs):
        super(VanillaGNNLayer, self).__init__(**kwargs)
        self.dim_out = dim_out
        self.kernel_initializer = kernel_initializer
        self.linear = None

    def build(self, input_shape):
        self.linear = tf.keras.layers.Dense(
            self.dim_out, use_bias=False, kernel_initializer=self.kernel_initializer
        )
        super(VanillaGNNLayer, self).build(input_shape)

    def call(self, x, adjacency):
        x = self.linear(x)
        x = tf.sparse.sparse_dense_matmul(adjacency, x)
        return x

    def get_config(self):
        config = super(VanillaGNNLayer, self).get_config()
        config.update(
            {
                &#34;dim_out&#34;: self.dim_out,
                &#34;kernel_initializer&#34;: tf.keras.initializers.serialize(
                    self.linear.kernel_initializer
                ),
            }
        )
        return config


@tf.keras.utils.register_keras_serializable(package=&#34;Custom&#34;, name=&#34;VanillaGNN&#34;)
class VanillaGNN(tf.keras.Model):
    def __init__(self, dim_in, dim_h, dim_out, **kwargs):
        super(VanillaGNN, self).__init__(**kwargs)
        self.dim_in = dim_in
        self.dim_h = dim_h
        self.dim_out = dim_out
        self.gnn1 = VanillaGNNLayer(self.dim_in, self.dim_h)
        self.gnn2 = VanillaGNNLayer(self.dim_h, self.dim_h)
        self.gnn3 = VanillaGNNLayer(self.dim_h, self.dim_out)

    def build(self, input_shape):
        super(VanillaGNN, self).build(input_shape)
        dummy_input = tf.keras.Input(shape=input_shape[1:])
        dummy_adjacency = tf.sparse.SparseTensor(
            indices=[[0, 0]], values=[1.0], dense_shape=[input_shape[0], input_shape[0]]
        )
        _ = self(dummy_input, dummy_adjacency)

    def call(self, x, adjacency):
        h = self.gnn1(x, adjacency)
        h = tf.nn.tanh(h)
        h = self.gnn2(h, adjacency)
        h = self.gnn3(h, adjacency)
        return tf.nn.softmax(h, axis=1)

    def f1_macro(self, y_true, y_pred):
        return f1_score(y_true, y_pred, average=&#34;macro&#34;)

    def compute_f1_score(self, logits, labels):
        predictions = tf.argmax(logits, axis=1, output_type=tf.int32)
        true_labels = tf.cast(labels, tf.int32)
        return self.f1_macro(true_labels.numpy(), predictions.numpy())

    def evaluate(self, x, adjacency, y):
        y = tf.cast(y, tf.int32)
        out = self(x, adjacency)
        loss = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y, logits=out)
        loss = tf.reduce_mean(loss)
        f1 = self.compute_f1_score(out, y)
        return loss.numpy(), f1

    def test(self, data):
        out = self(data.x, data.adjacency)
        test_f1 = self.compute_f1_score(out, data.y)
        return test_f1

    def predict(self, data):
        out = self(data.x, data.adjacency)
        return tf.argmax(out, axis=1, output_type=tf.int32).numpy()

    def get_config(self):
        config = {
            &#34;dim_in&#34;: self.dim_in,
            &#34;dim_h&#34;: self.dim_h,
            &#34;dim_out&#34;: self.dim_out,
        }
        base_config = super(VanillaGNN, self).get_config()
        return dict(list(base_config.items()) + list(config.items()))

    @classmethod
    def from_config(cls, config):
        return cls(
            dim_in=config[&#34;dim_in&#34;],
            dim_h=config[&#34;dim_h&#34;],
            dim_out=config[&#34;dim_out&#34;],
        )

    @tf.function
    def train_step(self, batch_x, batch_adjacency, batch_y, optimizer):
        with tf.GradientTape() as tape:
            out = self(batch_x, batch_adjacency)
            loss = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=batch_y, logits=out)
            loss = tf.reduce_mean(loss)
        gradients = tape.gradient(loss, self.trainable_variables)
        optimizer.apply_gradients(zip(gradients, self.trainable_variables))
        return loss

    def fit(self, data, epochs, batch_size, test_size=0.2, optimizer=&#34;adam&#34;):
        warnings.warn(
            &#34;It is normal for validation metrics to underperform. Use the test method to validate after training.&#34;,
            UserWarning,
        )
        optimizers = {
            &#34;sgd&#34;: tf.keras.optimizers.SGD(),
            &#34;adam&#34;: tf.keras.optimizers.Adam(),
            &#34;adamw&#34;: tf.keras.optimizers.AdamW(),
            &#34;adadelta&#34;: tf.keras.optimizers.Adadelta(),
            &#34;rmsprop&#34;: tf.keras.optimizers.RMSprop(),
        }
        optimizer = optimizers[optimizer]
        train_losses = []
        train_f1_scores = []
        val_losses = []
        val_f1_scores = []

        X_train, X_test, y_train, y_test = train_test_split(
            data.x, data.y, test_size=test_size, shuffle=False
        )
        adjacency_train = tf.sparse.slice(data.adjacency, [0, 0], [len(X_train), len(X_train)])
        adjacency_test = tf.sparse.slice(
            data.adjacency, [len(X_train), 0], [len(X_test), len(X_test)]
        )

        batch_starts = np.arange(0, len(X_train), batch_size)
        for epoch in range(epochs):
            np.random.shuffle(batch_starts)
            for start in batch_starts:
                end = start + batch_size
                batch_x = X_train[start:end, :]
                batch_adjacency = tf.sparse.slice(
                    adjacency_train, [start, start], [batch_size, batch_size]
                )
                batch_y = y_train[start:end]
                train_loss = self.train_step(batch_x, batch_adjacency, batch_y, optimizer)

            train_loss, train_f1 = self.evaluate(X_train, adjacency_train, y_train)
            train_losses.append(train_loss)
            train_f1_scores.append(train_f1)

            if epoch % 2 == 0:
                val_loss, val_f1 = self.evaluate(X_test, adjacency_test, y_test)
                val_losses.append(val_loss)
                val_f1_scores.append(val_f1)
                print(
                    f&#34;Epoch {epoch:&gt;3} | Train Loss: {train_loss:.3f} | Train F1: {train_f1:.3f} | Val Loss: {val_loss:.3f} | Val F1: {val_f1:.3f}&#34;
                )

        return train_losses, train_f1_scores, val_losses, val_f1_scores


if __name__ == &#34;__main__&#34;:
    # Example usage
    import pandas as pd
    from sklearn.datasets import load_iris

    # Load the dataset
    iris = load_iris()

    # Convert to a DataFrame for easy exploration
    iris_df = pd.DataFrame(data=iris.data, columns=iris.feature_names)
    iris_df[&#34;species&#34;] = iris.target

    iris_df[&#34;sepal length (cm)&#34;] = iris_df[&#34;sepal length (cm)&#34;].astype(&#34;category&#34;)
    iris_df[&#34;sepal width (cm)&#34;] = iris_df[&#34;sepal width (cm)&#34;].astype(&#34;category&#34;)
    iris_df[&#34;petal length (cm)&#34;] = iris_df[&#34;petal length (cm)&#34;].astype(&#34;category&#34;)
    iris_df[&#34;petal width (cm)&#34;] = iris_df[&#34;petal width (cm)&#34;].astype(&#34;category&#34;)

    # Display the first few rows of the dataset
    print(iris_df.head())

    iris_df = iris_df.sample(frac=1, replace=False).reset_index(drop=True)

    data = Data(iris_df, &#34;species&#34;)

    model = VanillaGNN(dim_in=data.x.shape[1], dim_h=8, dim_out=len(iris_df[&#34;species&#34;].unique()))
    print(&#34;Before training F1:&#34;, model.test(data))
    model.fit(data, epochs=200, batch_size=32, test_size=0.5)
    model.save(&#34;./best_model.keras&#34;)
    print(&#34;After training F1:&#34;, model.test(data))
    best_model = tf.keras.models.load_model(&#34;./best_model.keras&#34;)

    print(&#34;After loading F1:&#34;, best_model.test(data))
    df_results = pd.DataFrame()

    # Suppose we have a new dataset without the target variable
    iris_df = iris_df.drop(columns=[&#34;species&#34;])
    data_new = Data(iris_df)
    print(&#34;Predictions:&#34;, best_model.predict(data_new))
    df_results[&#34;predicted&#34;] = list(model.predict(data))
    df_results[&#34;actual&#34;] = list(data.y)
    # df_results.to_csv(&#34;results.csv&#34;, index=False)
    breakpoint()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="likelihood.graph.nn.cal_adjency_matrix"><code class="name flex">
<span>def <span class="ident">cal_adjency_matrix</span></span>(<span>df: pandas.core.frame.DataFrame, exclude_subset: List[str] = [], sparse: bool = True, **kwargs) ‑> Tuple[dict, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the adjacency matrix for a given DataFrame.
The adjacency matrix is a matrix that represents the similarity between each pair of categories.
The similarity is calculated using the <code><a title="likelihood.graph.nn.compare_similarity" href="#likelihood.graph.nn.compare_similarity">compare_similarity()</a></code> function.
The resulting matrix is a square matrix with the same number of rows and columns as the input DataFrame.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>The input DataFrame containing the categories.</dd>
<dt><strong><code>exclude_subset</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>A list of categories to exclude from the calculation of the adjacency matrix.</dd>
<dt><strong><code>sparse</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to return a sparse matrix or a dense matrix.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Additional keyword arguments to pass to the <code><a title="likelihood.graph.nn.compare_similarity" href="#likelihood.graph.nn.compare_similarity">compare_similarity()</a></code> function.</dd>
</dl>
<h2 id="keyword-arguments">Keyword Arguments:</h2>
<p>similarity: <code>int</code>
The minimum number of categories that must be the same in both arrays to be considered similar.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>adj_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing the categories.</dd>
<dt><strong><code>adjacency_matrix</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>The adjacency matrix.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cal_adjency_matrix(
    df: DataFrame, exclude_subset: List[str] = [], sparse: bool = True, **kwargs
) -&gt; Tuple[dict, ndarray]:
    &#34;&#34;&#34;Calculates the adjacency matrix for a given DataFrame.
    The adjacency matrix is a matrix that represents the similarity between each pair of categories.
    The similarity is calculated using the `compare_similarity` function.
    The resulting matrix is a square matrix with the same number of rows and columns as the input DataFrame.

    Parameters
    ----------
    df : `DataFrame`
        The input DataFrame containing the categories.
    exclude_subset : `List[str]`, optional
        A list of categories to exclude from the calculation of the adjacency matrix.
    sparse : `bool`, optional
        Whether to return a sparse matrix or a dense matrix.
    **kwargs : `dict`
        Additional keyword arguments to pass to the `compare_similarity` function.

    Keyword Arguments:
    ----------
    similarity: `int`
        The minimum number of categories that must be the same in both arrays to be considered similar.

    Returns
    -------
    adj_dict : `dict`
        A dictionary containing the categories.
    adjacency_matrix : `ndarray`
        The adjacency matrix.
    &#34;&#34;&#34;

    yaml_ = generate_feature_yaml(df)
    categorical_columns = yaml_[&#34;categorical_features&#34;]
    if len(exclude_subset) &gt; 0:
        categorical_columns = [col for col in categorical_columns if col not in exclude_subset]

    if len(categorical_columns) &gt; 1:
        df_categorical = df[categorical_columns].copy()
    else:
        categorical_columns = [
            col
            for col in df.columns
            if (
                col not in exclude_subset
                and pd.api.types.is_integer_dtype(df[col])
                and len(df[col].unique()) &gt; 2
            )
        ]
        df_categorical = df[categorical_columns].copy()

    assert len(df_categorical) &gt; 0

    similarity = kwargs[&#34;similarity&#34;] if &#34;similarity&#34; in kwargs else len(df_categorical.columns) - 1
    assert similarity &lt;= df_categorical.shape[1]

    adj_dict = {}
    for index, row in df_categorical.iterrows():
        adj_dict[index] = row.to_list()

    adjacency_matrix = np.zeros((len(df_categorical), len(df_categorical)))

    for i in range(len(df_categorical)):
        for j in range(len(df_categorical)):
            if compare_similarity(adj_dict[i], adj_dict[j]) &gt;= similarity:
                adjacency_matrix[i][j] = 1

    if sparse:
        num_nodes = adjacency_matrix.shape[0]

        indices = np.argwhere(adjacency_matrix != 0.0)
        indices = tf.constant(indices, dtype=tf.int64)
        values = tf.constant(adjacency_matrix[indices[:, 0], indices[:, 1]], dtype=tf.float32)
        adjacency_matrix = tf.sparse.SparseTensor(
            indices=indices, values=values, dense_shape=(num_nodes, num_nodes)
        )

        return adj_dict, adjacency_matrix
    else:
        return adj_dict, adjacency_matrix</code></pre>
</details>
</dd>
<dt id="likelihood.graph.nn.compare_similarity"><code class="name flex">
<span>def <span class="ident">compare_similarity</span></span>(<span>arr1: numpy.ndarray, arr2: numpy.ndarray) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Compares the similarity between two arrays of categories.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>arr1</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>The first array of categories.</dd>
<dt><strong><code>arr2</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>The second array of categories.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>count</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of categories that are the same in both arrays.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_similarity(arr1: ndarray, arr2: ndarray) -&gt; int:
    &#34;&#34;&#34;Compares the similarity between two arrays of categories.

    Parameters
    ----------
    arr1 : `ndarray`
        The first array of categories.
    arr2 : `ndarray`
        The second array of categories.

    Returns
    -------
    count: `int`
        The number of categories that are the same in both arrays.
    &#34;&#34;&#34;

    count = 0
    for i in range(len(arr1)):
        if arr1[i] == arr2[i]:
            count += 1
    return count</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="likelihood.graph.nn.Data"><code class="flex name class">
<span>class <span class="ident">Data</span></span>
<span>(</span><span>df: pandas.core.frame.DataFrame, target: str | None = None, exclude_subset: List[str] = [])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Data:
    def __init__(
        self,
        df: DataFrame,
        target: str | None = None,
        exclude_subset: List[str] = [],
    ):
        _, adjacency = cal_adjency_matrix(df, exclude_subset=exclude_subset, sparse=True)
        if target is not None:
            X = df.drop(columns=[target] + exclude_subset)
        else:
            X = df.drop(columns=exclude_subset)
        self.columns = X.columns
        X = X.to_numpy()
        self.x = np.asarray(X).astype(np.float32)
        self.adjacency = adjacency
        if target is not None:
            self.y = np.asarray(df[target].values).astype(np.int32)</code></pre>
</details>
</dd>
<dt id="likelihood.graph.nn.VanillaGNN"><code class="flex name class">
<span>class <span class="ident">VanillaGNN</span></span>
<span>(</span><span>dim_in, dim_h, dim_out, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A model grouping layers into an object with training/inference features.</p>
<p>There are three ways to instantiate a <code>Model</code>:</p>
<h2 id="with-the-functional-api">With the "Functional API"</h2>
<p>You start from <code>Input</code>,
you chain layer calls to specify the model's forward pass,
and finally you create your model from inputs and outputs:</p>
<pre><code class="language-python">inputs = keras.Input(shape=(37,))
x = keras.layers.Dense(32, activation=&quot;relu&quot;)(inputs)
outputs = keras.layers.Dense(5, activation=&quot;softmax&quot;)(x)
model = keras.Model(inputs=inputs, outputs=outputs)
</code></pre>
<p>Note: Only dicts, lists, and tuples of input tensors are supported. Nested
inputs are not supported (e.g. lists of list or dicts of dict).</p>
<p>A new Functional API model can also be created by using the
intermediate tensors. This enables you to quickly extract sub-components
of the model.</p>
<p>Example:</p>
<pre><code class="language-python">inputs = keras.Input(shape=(None, None, 3))
processed = keras.layers.RandomCrop(width=128, height=128)(inputs)
conv = keras.layers.Conv2D(filters=32, kernel_size=3)(processed)
pooling = keras.layers.GlobalAveragePooling2D()(conv)
feature = keras.layers.Dense(10)(pooling)

full_model = keras.Model(inputs, feature)
backbone = keras.Model(processed, conv)
activations = keras.Model(conv, feature)
</code></pre>
<p>Note that the <code>backbone</code> and <code>activations</code> models are not
created with <code>keras.Input</code> objects, but with the tensors that originate
from <code>keras.Input</code> objects. Under the hood, the layers and weights will
be shared across these models, so that user can train the <code>full_model</code>, and
use <code>backbone</code> or <code>activations</code> to do feature extraction.
The inputs and outputs of the model can be nested structures of tensors as
well, and the created models are standard Functional API models that support
all the existing APIs.</p>
<h2 id="by-subclassing-the-model-class">By subclassing the <code>Model</code> class</h2>
<p>In that case, you should define your
layers in <code>__init__()</code> and you should implement the model's forward pass
in <code>call()</code>.</p>
<pre><code class="language-python">class MyModel(keras.Model):
    def __init__(self):
        super().__init__()
        self.dense1 = keras.layers.Dense(32, activation=&quot;relu&quot;)
        self.dense2 = keras.layers.Dense(5, activation=&quot;softmax&quot;)

    def call(self, inputs):
        x = self.dense1(inputs)
        return self.dense2(x)

model = MyModel()
</code></pre>
<p>If you subclass <code>Model</code>, you can optionally have
a <code>training</code> argument (boolean) in <code>call()</code>, which you can use to specify
a different behavior in training and inference:</p>
<pre><code class="language-python">class MyModel(keras.Model):
    def __init__(self):
        super().__init__()
        self.dense1 = keras.layers.Dense(32, activation=&quot;relu&quot;)
        self.dense2 = keras.layers.Dense(5, activation=&quot;softmax&quot;)
        self.dropout = keras.layers.Dropout(0.5)

    def call(self, inputs, training=False):
        x = self.dense1(inputs)
        x = self.dropout(x, training=training)
        return self.dense2(x)

model = MyModel()
</code></pre>
<p>Once the model is created, you can config the model with losses and metrics
with <code>model.compile()</code>, train the model with <code>model.fit()</code>, or use the model
to do prediction with <code>model.predict()</code>.</p>
<h2 id="with-the-sequential-class">With the <code>Sequential</code> class</h2>
<p>In addition, <code>keras.Sequential</code> is a special case of model where
the model is purely a stack of single-input, single-output layers.</p>
<pre><code class="language-python">model = keras.Sequential([
    keras.Input(shape=(None, None, 3)),
    keras.layers.Conv2D(filters=32, kernel_size=3),
])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@tf.keras.utils.register_keras_serializable(package=&#34;Custom&#34;, name=&#34;VanillaGNN&#34;)
class VanillaGNN(tf.keras.Model):
    def __init__(self, dim_in, dim_h, dim_out, **kwargs):
        super(VanillaGNN, self).__init__(**kwargs)
        self.dim_in = dim_in
        self.dim_h = dim_h
        self.dim_out = dim_out
        self.gnn1 = VanillaGNNLayer(self.dim_in, self.dim_h)
        self.gnn2 = VanillaGNNLayer(self.dim_h, self.dim_h)
        self.gnn3 = VanillaGNNLayer(self.dim_h, self.dim_out)

    def build(self, input_shape):
        super(VanillaGNN, self).build(input_shape)
        dummy_input = tf.keras.Input(shape=input_shape[1:])
        dummy_adjacency = tf.sparse.SparseTensor(
            indices=[[0, 0]], values=[1.0], dense_shape=[input_shape[0], input_shape[0]]
        )
        _ = self(dummy_input, dummy_adjacency)

    def call(self, x, adjacency):
        h = self.gnn1(x, adjacency)
        h = tf.nn.tanh(h)
        h = self.gnn2(h, adjacency)
        h = self.gnn3(h, adjacency)
        return tf.nn.softmax(h, axis=1)

    def f1_macro(self, y_true, y_pred):
        return f1_score(y_true, y_pred, average=&#34;macro&#34;)

    def compute_f1_score(self, logits, labels):
        predictions = tf.argmax(logits, axis=1, output_type=tf.int32)
        true_labels = tf.cast(labels, tf.int32)
        return self.f1_macro(true_labels.numpy(), predictions.numpy())

    def evaluate(self, x, adjacency, y):
        y = tf.cast(y, tf.int32)
        out = self(x, adjacency)
        loss = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y, logits=out)
        loss = tf.reduce_mean(loss)
        f1 = self.compute_f1_score(out, y)
        return loss.numpy(), f1

    def test(self, data):
        out = self(data.x, data.adjacency)
        test_f1 = self.compute_f1_score(out, data.y)
        return test_f1

    def predict(self, data):
        out = self(data.x, data.adjacency)
        return tf.argmax(out, axis=1, output_type=tf.int32).numpy()

    def get_config(self):
        config = {
            &#34;dim_in&#34;: self.dim_in,
            &#34;dim_h&#34;: self.dim_h,
            &#34;dim_out&#34;: self.dim_out,
        }
        base_config = super(VanillaGNN, self).get_config()
        return dict(list(base_config.items()) + list(config.items()))

    @classmethod
    def from_config(cls, config):
        return cls(
            dim_in=config[&#34;dim_in&#34;],
            dim_h=config[&#34;dim_h&#34;],
            dim_out=config[&#34;dim_out&#34;],
        )

    @tf.function
    def train_step(self, batch_x, batch_adjacency, batch_y, optimizer):
        with tf.GradientTape() as tape:
            out = self(batch_x, batch_adjacency)
            loss = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=batch_y, logits=out)
            loss = tf.reduce_mean(loss)
        gradients = tape.gradient(loss, self.trainable_variables)
        optimizer.apply_gradients(zip(gradients, self.trainable_variables))
        return loss

    def fit(self, data, epochs, batch_size, test_size=0.2, optimizer=&#34;adam&#34;):
        warnings.warn(
            &#34;It is normal for validation metrics to underperform. Use the test method to validate after training.&#34;,
            UserWarning,
        )
        optimizers = {
            &#34;sgd&#34;: tf.keras.optimizers.SGD(),
            &#34;adam&#34;: tf.keras.optimizers.Adam(),
            &#34;adamw&#34;: tf.keras.optimizers.AdamW(),
            &#34;adadelta&#34;: tf.keras.optimizers.Adadelta(),
            &#34;rmsprop&#34;: tf.keras.optimizers.RMSprop(),
        }
        optimizer = optimizers[optimizer]
        train_losses = []
        train_f1_scores = []
        val_losses = []
        val_f1_scores = []

        X_train, X_test, y_train, y_test = train_test_split(
            data.x, data.y, test_size=test_size, shuffle=False
        )
        adjacency_train = tf.sparse.slice(data.adjacency, [0, 0], [len(X_train), len(X_train)])
        adjacency_test = tf.sparse.slice(
            data.adjacency, [len(X_train), 0], [len(X_test), len(X_test)]
        )

        batch_starts = np.arange(0, len(X_train), batch_size)
        for epoch in range(epochs):
            np.random.shuffle(batch_starts)
            for start in batch_starts:
                end = start + batch_size
                batch_x = X_train[start:end, :]
                batch_adjacency = tf.sparse.slice(
                    adjacency_train, [start, start], [batch_size, batch_size]
                )
                batch_y = y_train[start:end]
                train_loss = self.train_step(batch_x, batch_adjacency, batch_y, optimizer)

            train_loss, train_f1 = self.evaluate(X_train, adjacency_train, y_train)
            train_losses.append(train_loss)
            train_f1_scores.append(train_f1)

            if epoch % 2 == 0:
                val_loss, val_f1 = self.evaluate(X_test, adjacency_test, y_test)
                val_losses.append(val_loss)
                val_f1_scores.append(val_f1)
                print(
                    f&#34;Epoch {epoch:&gt;3} | Train Loss: {train_loss:.3f} | Train F1: {train_f1:.3f} | Val Loss: {val_loss:.3f} | Val F1: {val_f1:.3f}&#34;
                )

        return train_losses, train_f1_scores, val_losses, val_f1_scores</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>keras.src.models.model.Model</li>
<li>keras.src.backend.tensorflow.trainer.TensorFlowTrainer</li>
<li>keras.src.trainers.trainer.Trainer</li>
<li>keras.src.layers.layer.Layer</li>
<li>keras.src.backend.tensorflow.layer.TFLayer</li>
<li>keras.src.backend.tensorflow.trackable.KerasAutoTrackable</li>
<li>tensorflow.python.trackable.autotrackable.AutoTrackable</li>
<li>tensorflow.python.trackable.base.Trackable</li>
<li>keras.src.ops.operation.Operation</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="likelihood.graph.nn.VanillaGNN.from_config"><code class="name flex">
<span>def <span class="ident">from_config</span></span>(<span>config)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a layer from its config.</p>
<p>This method is the reverse of <code>get_config</code>,
capable of instantiating the same layer from the config
dictionary. It does not handle layer connectivity
(handled by Network), nor weights (handled by <code>set_weights</code>).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>A Python dictionary, typically the
output of get_config.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A layer instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_config(cls, config):
    return cls(
        dim_in=config[&#34;dim_in&#34;],
        dim_h=config[&#34;dim_h&#34;],
        dim_out=config[&#34;dim_out&#34;],
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="likelihood.graph.nn.VanillaGNN.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self, input_shape)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self, input_shape):
    super(VanillaGNN, self).build(input_shape)
    dummy_input = tf.keras.Input(shape=input_shape[1:])
    dummy_adjacency = tf.sparse.SparseTensor(
        indices=[[0, 0]], values=[1.0], dense_shape=[input_shape[0], input_shape[0]]
    )
    _ = self(dummy_input, dummy_adjacency)</code></pre>
</details>
</dd>
<dt id="likelihood.graph.nn.VanillaGNN.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, x, adjacency)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, x, adjacency):
    h = self.gnn1(x, adjacency)
    h = tf.nn.tanh(h)
    h = self.gnn2(h, adjacency)
    h = self.gnn3(h, adjacency)
    return tf.nn.softmax(h, axis=1)</code></pre>
</details>
</dd>
<dt id="likelihood.graph.nn.VanillaGNN.compute_f1_score"><code class="name flex">
<span>def <span class="ident">compute_f1_score</span></span>(<span>self, logits, labels)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_f1_score(self, logits, labels):
    predictions = tf.argmax(logits, axis=1, output_type=tf.int32)
    true_labels = tf.cast(labels, tf.int32)
    return self.f1_macro(true_labels.numpy(), predictions.numpy())</code></pre>
</details>
</dd>
<dt id="likelihood.graph.nn.VanillaGNN.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, x, adjacency, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the loss value &amp; metrics values for the model in test mode.</p>
<p>Computation is done in batches (see the <code>batch_size</code> arg.)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>Input data. It could be:
- A NumPy array (or array-like), or a list of arrays
(in case the model has multiple inputs).
- A tensor, or a list of tensors
(in case the model has multiple inputs).
- A dict mapping input names to the corresponding array/tensors,
if the model has named inputs.
- A <code>tf.data.Dataset</code>. Should return a tuple
of either <code>(inputs, targets)</code> or
<code>(inputs, targets, sample_weights)</code>.
- A generator or <code>keras.utils.PyDataset</code> returning
<code>(inputs, targets)</code> or <code>(inputs, targets, sample_weights)</code>.</dd>
<dt><strong><code>y</code></strong></dt>
<dd>Target data. Like the input data <code>x</code>, it could be either NumPy
array(s) or backend-native tensor(s).
If <code>x</code> is a <code>tf.data.Dataset</code> or <code>keras.utils.PyDataset</code>
instance, <code>y</code> should not be specified
(since targets will be obtained from the iterator/dataset).</dd>
<dt><strong><code>batch_size</code></strong></dt>
<dd>Integer or <code>None</code>. Number of samples per batch of
computation. If unspecified, <code>batch_size</code> will default to 32. Do
not specify the <code>batch_size</code> if your data is in the form of a
dataset, generators, or <code>keras.utils.PyDataset</code> instances
(since they generate batches).</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd><code>"auto"</code>, 0, 1, or 2. Verbosity mode.
0 = silent, 1 = progress bar, 2 = single line.
<code>"auto"</code> becomes 1 for most cases.
Note that the progress bar is not
particularly useful when logged to a file, so <code>verbose=2</code> is
recommended when not running interactively
(e.g. in a production environment). Defaults to <code>"auto"</code>.</dd>
<dt><strong><code>sample_weight</code></strong></dt>
<dd>Optional NumPy array of weights for the test samples,
used for weighting the loss function. You can either pass a flat
(1D) NumPy array with the same length as the input samples
(1:1 mapping between weights and samples), or in the case of
temporal data, you can pass a 2D array with shape <code>(samples,
sequence_length)</code>, to apply a different weight to every
timestep of every sample. This argument is not supported when
<code>x</code> is a dataset, instead pass sample weights as the third
element of <code>x</code>.</dd>
<dt><strong><code>steps</code></strong></dt>
<dd>Integer or <code>None</code>. Total number of steps (batches of samples)
before declaring the evaluation round finished. Ignored with the
default value of <code>None</code>. If <code>x</code> is a <code>tf.data.Dataset</code> and
<code>steps</code> is <code>None</code>, evaluation will run until the dataset
is exhausted.</dd>
<dt><strong><code>callbacks</code></strong></dt>
<dd>List of <code>keras.callbacks.Callback</code> instances.
List of callbacks to apply during evaluation.</dd>
<dt><strong><code>return_dict</code></strong></dt>
<dd>If <code>True</code>, loss and metric results are returned as a
dict, with each key being the name of the metric.
If <code>False</code>, they are returned as a list.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Scalar test loss (if the model has a single output and no metrics)
or list of scalars (if the model has multiple outputs
and/or metrics). The attribute <code>model.metrics_names</code> will give you
the display labels for the scalar outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, x, adjacency, y):
    y = tf.cast(y, tf.int32)
    out = self(x, adjacency)
    loss = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y, logits=out)
    loss = tf.reduce_mean(loss)
    f1 = self.compute_f1_score(out, y)
    return loss.numpy(), f1</code></pre>
</details>
</dd>
<dt id="likelihood.graph.nn.VanillaGNN.f1_macro"><code class="name flex">
<span>def <span class="ident">f1_macro</span></span>(<span>self, y_true, y_pred)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f1_macro(self, y_true, y_pred):
    return f1_score(y_true, y_pred, average=&#34;macro&#34;)</code></pre>
</details>
</dd>
<dt id="likelihood.graph.nn.VanillaGNN.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, data, epochs, batch_size, test_size=0.2, optimizer='adam')</span>
</code></dt>
<dd>
<div class="desc"><p>Trains the model for a fixed number of epochs (dataset iterations).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>Input data. It could be:
- A NumPy array (or array-like), or a list of arrays
(in case the model has multiple inputs).
- A tensor, or a list of tensors
(in case the model has multiple inputs).
- A dict mapping input names to the corresponding array/tensors,
if the model has named inputs.
- A <code>tf.data.Dataset</code>. Should return a tuple
of either <code>(inputs, targets)</code> or
<code>(inputs, targets, sample_weights)</code>.
- A <code>keras.utils.PyDataset</code> returning <code>(inputs,
targets)&lt;code&gt; or &lt;/code&gt;(inputs, targets, sample_weights)</code>.</dd>
<dt><strong><code>y</code></strong></dt>
<dd>Target data. Like the input data <code>x</code>,
it could be either NumPy array(s) or backend-native tensor(s).
If <code>x</code> is a dataset, generator,
or <code>keras.utils.PyDataset</code> instance, <code>y</code> should
not be specified (since targets will be obtained from <code>x</code>).</dd>
<dt><strong><code>batch_size</code></strong></dt>
<dd>Integer or <code>None</code>.
Number of samples per gradient update.
If unspecified, <code>batch_size</code> will default to 32.
Do not specify the <code>batch_size</code> if your data is in the
form of datasets, generators, or <code>keras.utils.PyDataset</code>
instances (since they generate batches).</dd>
<dt><strong><code>epochs</code></strong></dt>
<dd>Integer. Number of epochs to train the model.
An epoch is an iteration over the entire <code>x</code> and <code>y</code>
data provided
(unless the <code>steps_per_epoch</code> flag is set to
something other than None).
Note that in conjunction with <code>initial_epoch</code>,
<code>epochs</code> is to be understood as "final epoch".
The model is not trained for a number of iterations
given by <code>epochs</code>, but merely until the epoch
of index <code>epochs</code> is reached.</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd><code>"auto"</code>, 0, 1, or 2. Verbosity mode.
0 = silent, 1 = progress bar, 2 = one line per epoch.
"auto" becomes 1 for most cases.
Note that the progress bar is not
particularly useful when logged to a file,
so <code>verbose=2</code> is recommended when not running interactively
(e.g., in a production environment). Defaults to <code>"auto"</code>.</dd>
<dt><strong><code>callbacks</code></strong></dt>
<dd>List of <code>keras.callbacks.Callback</code> instances.
List of callbacks to apply during training.
See <code>keras.callbacks</code>. Note
<code>keras.callbacks.ProgbarLogger</code> and
<code>keras.callbacks.History</code> callbacks are created
automatically and need not be passed to <code>model.fit()</code>.
<code>keras.callbacks.ProgbarLogger</code> is created
or not based on the <code>verbose</code> argument in <code>model.fit()</code>.</dd>
<dt><strong><code>validation_split</code></strong></dt>
<dd>Float between 0 and 1.
Fraction of the training data to be used as validation data.
The model will set apart this fraction of the training data,
will not train on it, and will evaluate
the loss and any model metrics
on this data at the end of each epoch.
The validation data is selected from the last samples
in the <code>x</code> and <code>y</code> data provided, before shuffling. This
argument is not supported when <code>x</code> is a dataset, generator or
<code>keras.utils.PyDataset</code> instance.
If both <code>validation_data</code> and <code>validation_split</code> are provided,
<code>validation_data</code> will override <code>validation_split</code>.</dd>
<dt><strong><code>validation_data</code></strong></dt>
<dd>Data on which to evaluate
the loss and any model metrics at the end of each epoch.
The model will not be trained on this data. Thus, note the fact
that the validation loss of data provided using
<code>validation_split</code> or <code>validation_data</code> is not affected by
regularization layers like noise and dropout.
<code>validation_data</code> will override <code>validation_split</code>.
It could be:
- A tuple <code>(x_val, y_val)</code> of NumPy arrays or tensors.
- A tuple <code>(x_val, y_val, val_sample_weights)</code> of NumPy
arrays.
- A <code>tf.data.Dataset</code>.
- A Python generator or <code>keras.utils.PyDataset</code> returning
<code>(inputs, targets)</code> or <code>(inputs, targets, sample_weights)</code>.</dd>
<dt><strong><code>shuffle</code></strong></dt>
<dd>Boolean, whether to shuffle the training data
before each epoch. This argument is
ignored when <code>x</code> is a generator or a <code>tf.data.Dataset</code>.</dd>
<dt><strong><code>class_weight</code></strong></dt>
<dd>Optional dictionary mapping class indices (integers)
to a weight (float) value, used for weighting the loss function
(during training only).
This can be useful to tell the model to
"pay more attention" to samples from
an under-represented class. When <code>class_weight</code> is specified
and targets have a rank of 2 or greater, either <code>y</code> must be
one-hot encoded, or an explicit final dimension of <code>1</code> must
be included for sparse class labels.</dd>
<dt><strong><code>sample_weight</code></strong></dt>
<dd>Optional NumPy array of weights for
the training samples, used for weighting the loss function
(during training only). You can either pass a flat (1D)
NumPy array with the same length as the input samples
(1:1 mapping between weights and samples),
or in the case of temporal data,
you can pass a 2D array with shape
<code>(samples, sequence_length)</code>,
to apply a different weight to every timestep of every sample.
This argument is not supported when <code>x</code> is a dataset, generator,
or <code>keras.utils.PyDataset</code> instance, instead provide the
sample_weights as the third element of <code>x</code>.
Note that sample weighting does not apply to metrics specified
via the <code>metrics</code> argument in <code>compile()</code>. To apply sample
weighting to your metrics, you can specify them via the
<code>weighted_metrics</code> in <code>compile()</code> instead.</dd>
<dt><strong><code>initial_epoch</code></strong></dt>
<dd>Integer.
Epoch at which to start training
(useful for resuming a previous training run).</dd>
<dt><strong><code>steps_per_epoch</code></strong></dt>
<dd>Integer or <code>None</code>.
Total number of steps (batches of samples)
before declaring one epoch finished and starting the
next epoch. When training with input tensors such as
backend-native tensors, the default <code>None</code> is equal to
the number of samples in your dataset divided by
the batch size, or 1 if that cannot be determined. If <code>x</code> is a
<code>tf.data.Dataset</code>, and <code>steps_per_epoch</code>
is <code>None</code>, the epoch will run until the input dataset is
exhausted.
When passing an infinitely repeating dataset, you
must specify the <code>steps_per_epoch</code> argument. If
<code>steps_per_epoch=-1</code> the training will run indefinitely with an
infinitely repeating dataset.</dd>
<dt><strong><code>validation_steps</code></strong></dt>
<dd>Only relevant if <code>validation_data</code> is provided.
Total number of steps (batches of
samples) to draw before stopping when performing validation
at the end of every epoch. If <code>validation_steps</code> is <code>None</code>,
validation will run until the <code>validation_data</code> dataset is
exhausted. In the case of an infinitely repeated dataset, it
will run into an infinite loop. If <code>validation_steps</code> is
specified and only part of the dataset will be consumed, the
evaluation will start from the beginning of the dataset at each
epoch. This ensures that the same validation samples are used
every time.</dd>
<dt><strong><code>validation_batch_size</code></strong></dt>
<dd>Integer or <code>None</code>.
Number of samples per validation batch.
If unspecified, will default to <code>batch_size</code>.
Do not specify the <code>validation_batch_size</code> if your data is in
the form of datasets or <code>keras.utils.PyDataset</code>
instances (since they generate batches).</dd>
<dt><strong><code>validation_freq</code></strong></dt>
<dd>Only relevant if validation data is provided.
Specifies how many training epochs to run
before a new validation run is performed,
e.g. <code>validation_freq=2</code> runs validation every 2 epochs.</dd>
</dl>
<p>Unpacking behavior for iterator-like inputs:
A common pattern is to pass an iterator like object such as a
<code>tf.data.Dataset</code> or a <code>keras.utils.PyDataset</code> to <code>fit()</code>,
which will in fact yield not only features (<code>x</code>)
but optionally targets (<code>y</code>) and sample weights (<code>sample_weight</code>).
Keras requires that the output of such iterator-likes be
unambiguous. The iterator should return a tuple
of length 1, 2, or 3, where the optional second and third elements
will be used for <code>y</code> and <code>sample_weight</code> respectively.
Any other type provided will be wrapped in
a length-one tuple, effectively treating everything as <code>x</code>. When
yielding dicts, they should still adhere to the top-level tuple
structure,
e.g. <code>({"x0": x0, "x1": x1}, y)</code>. Keras will not attempt to separate
features, targets, and weights from the keys of a single dict.
A notable unsupported data type is the <code>namedtuple</code>. The reason is
that it behaves like both an ordered datatype (tuple) and a mapping
datatype (dict). So given a namedtuple of the form:
<code>namedtuple("example_tuple", ["y", "x"])</code>
it is ambiguous whether to reverse the order of the elements when
interpreting the value. Even worse is a tuple of the form:
<code>namedtuple("other_tuple", ["x", "y", "z"])</code>
where it is unclear if the tuple was intended to be unpacked
into <code>x</code>, <code>y</code>, and <code>sample_weight</code> or passed through
as a single element to <code>x</code>.</p>
<h2 id="returns">Returns</h2>
<p>A <code>History</code> object. Its <code>History.history</code> attribute is
a record of training loss values and metrics values
at successive epochs, as well as validation loss values
and validation metrics values (if applicable).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self, data, epochs, batch_size, test_size=0.2, optimizer=&#34;adam&#34;):
    warnings.warn(
        &#34;It is normal for validation metrics to underperform. Use the test method to validate after training.&#34;,
        UserWarning,
    )
    optimizers = {
        &#34;sgd&#34;: tf.keras.optimizers.SGD(),
        &#34;adam&#34;: tf.keras.optimizers.Adam(),
        &#34;adamw&#34;: tf.keras.optimizers.AdamW(),
        &#34;adadelta&#34;: tf.keras.optimizers.Adadelta(),
        &#34;rmsprop&#34;: tf.keras.optimizers.RMSprop(),
    }
    optimizer = optimizers[optimizer]
    train_losses = []
    train_f1_scores = []
    val_losses = []
    val_f1_scores = []

    X_train, X_test, y_train, y_test = train_test_split(
        data.x, data.y, test_size=test_size, shuffle=False
    )
    adjacency_train = tf.sparse.slice(data.adjacency, [0, 0], [len(X_train), len(X_train)])
    adjacency_test = tf.sparse.slice(
        data.adjacency, [len(X_train), 0], [len(X_test), len(X_test)]
    )

    batch_starts = np.arange(0, len(X_train), batch_size)
    for epoch in range(epochs):
        np.random.shuffle(batch_starts)
        for start in batch_starts:
            end = start + batch_size
            batch_x = X_train[start:end, :]
            batch_adjacency = tf.sparse.slice(
                adjacency_train, [start, start], [batch_size, batch_size]
            )
            batch_y = y_train[start:end]
            train_loss = self.train_step(batch_x, batch_adjacency, batch_y, optimizer)

        train_loss, train_f1 = self.evaluate(X_train, adjacency_train, y_train)
        train_losses.append(train_loss)
        train_f1_scores.append(train_f1)

        if epoch % 2 == 0:
            val_loss, val_f1 = self.evaluate(X_test, adjacency_test, y_test)
            val_losses.append(val_loss)
            val_f1_scores.append(val_f1)
            print(
                f&#34;Epoch {epoch:&gt;3} | Train Loss: {train_loss:.3f} | Train F1: {train_f1:.3f} | Val Loss: {val_loss:.3f} | Val F1: {val_f1:.3f}&#34;
            )

    return train_losses, train_f1_scores, val_losses, val_f1_scores</code></pre>
</details>
</dd>
<dt id="likelihood.graph.nn.VanillaGNN.get_config"><code class="name flex">
<span>def <span class="ident">get_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the config of the object.</p>
<p>An object config is a Python dictionary (serializable)
containing the information needed to re-instantiate it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_config(self):
    config = {
        &#34;dim_in&#34;: self.dim_in,
        &#34;dim_h&#34;: self.dim_h,
        &#34;dim_out&#34;: self.dim_out,
    }
    base_config = super(VanillaGNN, self).get_config()
    return dict(list(base_config.items()) + list(config.items()))</code></pre>
</details>
</dd>
<dt id="likelihood.graph.nn.VanillaGNN.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates output predictions for the input samples.</p>
<p>Computation is done in batches. This method is designed for batch
processing of large numbers of inputs. It is not intended for use inside
of loops that iterate over your data and process small numbers of inputs
at a time.</p>
<p>For small numbers of inputs that fit in one batch,
directly use <code>__call__()</code> for faster execution, e.g.,
<code>model(x)</code>, or <code>model(x, training=False)</code> if you have layers such as
<code>BatchNormalization</code> that behave differently during
inference.</p>
<p>Note: See <a href="https://keras.io/getting_started/faq/#whats-the-difference-between-model-methods-predict-and-call">this FAQ entry</a>
for more details about the difference between <code>Model</code> methods
<code>predict()</code> and <code>__call__()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>Input samples. It could be:
- A NumPy array (or array-like), or a list of arrays
(in case the model has multiple inputs).
- A tensor, or a list of tensors
(in case the model has multiple inputs).
- A <code>tf.data.Dataset</code>.
- A <code>keras.utils.PyDataset</code> instance.</dd>
<dt><strong><code>batch_size</code></strong></dt>
<dd>Integer or <code>None</code>.
Number of samples per batch.
If unspecified, <code>batch_size</code> will default to 32.
Do not specify the <code>batch_size</code> if your data is in the
form of dataset, generators, or <code>keras.utils.PyDataset</code>
instances (since they generate batches).</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd><code>"auto"</code>, 0, 1, or 2. Verbosity mode.
0 = silent, 1 = progress bar, 2 = single line.
<code>"auto"</code> becomes 1 for most cases. Note that the progress bar
is not particularly useful when logged to a file,
so <code>verbose=2</code> is recommended when not running interactively
(e.g. in a production environment). Defaults to <code>"auto"</code>.</dd>
<dt><strong><code>steps</code></strong></dt>
<dd>Total number of steps (batches of samples)
before declaring the prediction round finished.
Ignored with the default value of <code>None</code>.
If <code>x</code> is a <code>tf.data.Dataset</code> and <code>steps</code> is <code>None</code>,
<code>predict()</code> will run until the input dataset is exhausted.</dd>
<dt><strong><code>callbacks</code></strong></dt>
<dd>List of <code>keras.callbacks.Callback</code> instances.
List of callbacks to apply during prediction.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>NumPy array(s) of predictions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict(self, data):
    out = self(data.x, data.adjacency)
    return tf.argmax(out, axis=1, output_type=tf.int32).numpy()</code></pre>
</details>
</dd>
<dt id="likelihood.graph.nn.VanillaGNN.test"><code class="name flex">
<span>def <span class="ident">test</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test(self, data):
    out = self(data.x, data.adjacency)
    test_f1 = self.compute_f1_score(out, data.y)
    return test_f1</code></pre>
</details>
</dd>
<dt id="likelihood.graph.nn.VanillaGNN.train_step"><code class="name flex">
<span>def <span class="ident">train_step</span></span>(<span>self, batch_x, batch_adjacency, batch_y, optimizer)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@tf.function
def train_step(self, batch_x, batch_adjacency, batch_y, optimizer):
    with tf.GradientTape() as tape:
        out = self(batch_x, batch_adjacency)
        loss = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=batch_y, logits=out)
        loss = tf.reduce_mean(loss)
    gradients = tape.gradient(loss, self.trainable_variables)
    optimizer.apply_gradients(zip(gradients, self.trainable_variables))
    return loss</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="likelihood.graph.nn.VanillaGNNLayer"><code class="flex name class">
<span>class <span class="ident">VanillaGNNLayer</span></span>
<span>(</span><span>dim_in, dim_out, kernel_initializer='glorot_uniform', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the class from which all layers inherit.</p>
<p>A layer is a callable object that takes as input one or more tensors and
that outputs one or more tensors. It involves <em>computation</em>, defined
in the <code>call()</code> method, and a <em>state</em> (weight variables). State can be
created:</p>
<ul>
<li>in <code>__init__()</code>, for instance via <code>self.add_weight()</code>;</li>
<li>in the optional <code>build()</code> method, which is invoked by the first
<code>__call__()</code> to the layer, and supplies the shape(s) of the input(s),
which may not have been known at initialization time.</li>
</ul>
<p>Layers are recursively composable: If you assign a Layer instance as an
attribute of another Layer, the outer layer will start tracking the weights
created by the inner layer. Nested layers should be instantiated in the
<code>__init__()</code> method or <code>build()</code> method.</p>
<p>Users will just instantiate a layer and then treat it as a callable.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>trainable</code></strong></dt>
<dd>Boolean, whether the layer's variables should be trainable.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>String name of the layer.</dd>
<dt><strong><code>dtype</code></strong></dt>
<dd>The dtype of the layer's computations and weights. Can also be a
<code>keras.DTypePolicy</code>,
which allows the computation and
weight dtype to differ. Defaults to <code>None</code>. <code>None</code> means to use
<code>keras.config.dtype_policy()</code>,
which is a <code>float32</code> policy unless set to different value
(via <code>keras.config.set_dtype_policy()</code>).</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the layer (string).</dd>
<dt><strong><code>dtype</code></strong></dt>
<dd>Dtype of the layer's weights. Alias of <code>layer.variable_dtype</code>.</dd>
<dt><strong><code>variable_dtype</code></strong></dt>
<dd>Dtype of the layer's weights.</dd>
<dt><strong><code>compute_dtype</code></strong></dt>
<dd>The dtype of the layer's computations.
Layers automatically cast inputs to this dtype, which causes
the computations and output to also be in this dtype.
When mixed precision is used with a
<code>keras.DTypePolicy</code>, this will be different
than <code>variable_dtype</code>.</dd>
<dt><strong><code>trainable_weights</code></strong></dt>
<dd>List of variables to be included in backprop.</dd>
<dt><strong><code>non_trainable_weights</code></strong></dt>
<dd>List of variables that should not be
included in backprop.</dd>
<dt><strong><code>weights</code></strong></dt>
<dd>The concatenation of the lists trainable_weights and
non_trainable_weights (in this order).</dd>
<dt><strong><code>trainable</code></strong></dt>
<dd>Whether the layer should be trained (boolean), i.e.
whether its potentially-trainable weights should be returned
as part of <code>layer.trainable_weights</code>.</dd>
<dt><strong><code>input_spec</code></strong></dt>
<dd>Optional (list of) <code>InputSpec</code> object(s) specifying the
constraints on inputs that can be accepted by the layer.</dd>
</dl>
<p>We recommend that descendants of <code>Layer</code> implement the following methods:</p>
<ul>
<li><code>__init__()</code>: Defines custom layer attributes, and creates layer weights
that do not depend on input shapes, using <code>add_weight()</code>,
or other state.</li>
<li><code>build(self, input_shape)</code>: This method can be used to create weights that
depend on the shape(s) of the input(s), using <code>add_weight()</code>, or other
state. <code>__call__()</code> will automatically build the layer
(if it has not been built yet) by calling <code>build()</code>.</li>
<li><code>call(self, *args, **kwargs)</code>: Called in <code>__call__</code> after making
sure <code>build()</code> has been called. <code>call()</code> performs the logic of applying
the layer to the input arguments.
Two reserved keyword arguments you can optionally use in <code>call()</code> are:
1. <code>training</code> (boolean, whether the call is in inference mode or
training mode).
2. <code>mask</code> (boolean tensor encoding masked timesteps in the input,
used e.g. in RNN layers).
A typical signature for this method is <code>call(self, inputs)</code>, and user
could optionally add <code>training</code> and <code>mask</code> if the layer need them.</li>
<li><code>get_config(self)</code>: Returns a dictionary containing the configuration
used to initialize this layer. If the keys differ from the arguments
in <code>__init__()</code>, then override <code>from_config(self)</code> as well.
This method is used when saving
the layer or a model that contains this layer.</li>
</ul>
<p>Examples:</p>
<p>Here's a basic example: a layer with two variables, <code>w</code> and <code>b</code>,
that returns <code>y = w . x + b</code>.
It shows how to implement <code>build()</code> and <code>call()</code>.
Variables set as attributes of a layer are tracked as weights
of the layers (in <code>layer.weights</code>).</p>
<pre><code class="language-python">class SimpleDense(Layer):
    def __init__(self, units=32):
        super().__init__()
        self.units = units

    # Create the state of the layer (weights)
    def build(self, input_shape):
        self.kernel = self.add_weight(
            shape=(input_shape[-1], self.units),
            initializer=&quot;glorot_uniform&quot;,
            trainable=True,
            name=&quot;kernel&quot;,
        )
        self.bias = self.add_weight(
            shape=(self.units,),
            initializer=&quot;zeros&quot;,
            trainable=True,
            name=&quot;bias&quot;,
        )

    # Defines the computation
    def call(self, inputs):
        return ops.matmul(inputs, self.kernel) + self.bias

# Instantiates the layer.
linear_layer = SimpleDense(4)

# This will also call `build(input_shape)` and create the weights.
y = linear_layer(ops.ones((2, 2)))
assert len(linear_layer.weights) == 2

# These weights are trainable, so they're listed in `trainable_weights`:
assert len(linear_layer.trainable_weights) == 2
</code></pre>
<p>Besides trainable weights, updated via backpropagation during training,
layers can also have non-trainable weights. These weights are meant to
be updated manually during <code>call()</code>. Here's a example layer that computes
the running sum of its inputs:</p>
<pre><code class="language-python">class ComputeSum(Layer):

  def __init__(self, input_dim):
      super(ComputeSum, self).__init__()
      # Create a non-trainable weight.
      self.total = self.add_weight(
        shape=(),
        initializer=&quot;zeros&quot;,
        trainable=False,
        name=&quot;total&quot;,
      )

  def call(self, inputs):
      self.total.assign(self.total + ops.sum(inputs))
      return self.total

my_sum = ComputeSum(2)
x = ops.ones((2, 2))
y = my_sum(x)

assert my_sum.weights == [my_sum.total]
assert my_sum.non_trainable_weights == [my_sum.total]
assert my_sum.trainable_weights == []
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@tf.keras.utils.register_keras_serializable(package=&#34;Custom&#34;, name=&#34;VanillaGNNLayer&#34;)
class VanillaGNNLayer(tf.keras.layers.Layer):
    def __init__(self, dim_in, dim_out, kernel_initializer=&#34;glorot_uniform&#34;, **kwargs):
        super(VanillaGNNLayer, self).__init__(**kwargs)
        self.dim_out = dim_out
        self.kernel_initializer = kernel_initializer
        self.linear = None

    def build(self, input_shape):
        self.linear = tf.keras.layers.Dense(
            self.dim_out, use_bias=False, kernel_initializer=self.kernel_initializer
        )
        super(VanillaGNNLayer, self).build(input_shape)

    def call(self, x, adjacency):
        x = self.linear(x)
        x = tf.sparse.sparse_dense_matmul(adjacency, x)
        return x

    def get_config(self):
        config = super(VanillaGNNLayer, self).get_config()
        config.update(
            {
                &#34;dim_out&#34;: self.dim_out,
                &#34;kernel_initializer&#34;: tf.keras.initializers.serialize(
                    self.linear.kernel_initializer
                ),
            }
        )
        return config</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>keras.src.layers.layer.Layer</li>
<li>keras.src.backend.tensorflow.layer.TFLayer</li>
<li>keras.src.backend.tensorflow.trackable.KerasAutoTrackable</li>
<li>tensorflow.python.trackable.autotrackable.AutoTrackable</li>
<li>tensorflow.python.trackable.base.Trackable</li>
<li>keras.src.ops.operation.Operation</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="likelihood.graph.nn.VanillaGNNLayer.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self, input_shape)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self, input_shape):
    self.linear = tf.keras.layers.Dense(
        self.dim_out, use_bias=False, kernel_initializer=self.kernel_initializer
    )
    super(VanillaGNNLayer, self).build(input_shape)</code></pre>
</details>
</dd>
<dt id="likelihood.graph.nn.VanillaGNNLayer.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, x, adjacency)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, x, adjacency):
    x = self.linear(x)
    x = tf.sparse.sparse_dense_matmul(adjacency, x)
    return x</code></pre>
</details>
</dd>
<dt id="likelihood.graph.nn.VanillaGNNLayer.get_config"><code class="name flex">
<span>def <span class="ident">get_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the config of the object.</p>
<p>An object config is a Python dictionary (serializable)
containing the information needed to re-instantiate it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_config(self):
    config = super(VanillaGNNLayer, self).get_config()
    config.update(
        {
            &#34;dim_out&#34;: self.dim_out,
            &#34;kernel_initializer&#34;: tf.keras.initializers.serialize(
                self.linear.kernel_initializer
            ),
        }
    )
    return config</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="likelihood.graph" href="index.html">likelihood.graph</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="likelihood.graph.nn.cal_adjency_matrix" href="#likelihood.graph.nn.cal_adjency_matrix">cal_adjency_matrix</a></code></li>
<li><code><a title="likelihood.graph.nn.compare_similarity" href="#likelihood.graph.nn.compare_similarity">compare_similarity</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="likelihood.graph.nn.Data" href="#likelihood.graph.nn.Data">Data</a></code></h4>
</li>
<li>
<h4><code><a title="likelihood.graph.nn.VanillaGNN" href="#likelihood.graph.nn.VanillaGNN">VanillaGNN</a></code></h4>
<ul class="two-column">
<li><code><a title="likelihood.graph.nn.VanillaGNN.build" href="#likelihood.graph.nn.VanillaGNN.build">build</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNN.call" href="#likelihood.graph.nn.VanillaGNN.call">call</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNN.compute_f1_score" href="#likelihood.graph.nn.VanillaGNN.compute_f1_score">compute_f1_score</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNN.evaluate" href="#likelihood.graph.nn.VanillaGNN.evaluate">evaluate</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNN.f1_macro" href="#likelihood.graph.nn.VanillaGNN.f1_macro">f1_macro</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNN.fit" href="#likelihood.graph.nn.VanillaGNN.fit">fit</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNN.from_config" href="#likelihood.graph.nn.VanillaGNN.from_config">from_config</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNN.get_config" href="#likelihood.graph.nn.VanillaGNN.get_config">get_config</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNN.predict" href="#likelihood.graph.nn.VanillaGNN.predict">predict</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNN.test" href="#likelihood.graph.nn.VanillaGNN.test">test</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNN.train_step" href="#likelihood.graph.nn.VanillaGNN.train_step">train_step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="likelihood.graph.nn.VanillaGNNLayer" href="#likelihood.graph.nn.VanillaGNNLayer">VanillaGNNLayer</a></code></h4>
<ul class="">
<li><code><a title="likelihood.graph.nn.VanillaGNNLayer.build" href="#likelihood.graph.nn.VanillaGNNLayer.build">build</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNNLayer.call" href="#likelihood.graph.nn.VanillaGNNLayer.call">call</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNNLayer.get_config" href="#likelihood.graph.nn.VanillaGNNLayer.get_config">get_config</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>